## 1. What are the key differences between Docker containers and virtual machines?

### Explanation:
Virtual Machines virtualize hardware; each VM runs its own OS, consuming more resources.  
Containers share the host OS kernel and isolate applications at the process level, making them lightweight and faster.

### Key Points:
- VM → Hardware-level virtualization  
- Container → OS-level virtualization  
- VMs boot in minutes; Containers in seconds  
- VM images are large (GBs); Container images are small (MBs)  
- Containers share the host kernel; VMs have their own OS  

### Real-World Example:
In our eCommerce project, we initially ran frontend, backend, and database on separate VMs.  
After switching to Docker containers, deployment became faster and resource usage dropped drastically.

---

## 2. How do Docker images differ from containers?

### Explanation:
A **Docker image** is a read-only **template** containing the application and dependencies.  
A **container** is a **running instance** of that image.

### Analogy:
Image = Class, Container = Object.

### Example:
We created an image `backend:v1` for our Java application.  
Each time we scaled up, new containers were created from the same image, ensuring consistency.

---

## 3. Explain the use of docker-compose and its advantages.

### Explanation:
`docker-compose` is used to define and manage **multi-container applications** using a YAML file.

### Advantages:
- Single command to start multiple services (`docker-compose up`)  
- Handles networking automatically  
- Simplifies local development and testing  
- Supports scaling and easy teardown  

### Real-World Example:
We used `docker-compose.yml` to deploy `frontend`, `backend`, and `mysql` together.  
One command started all three services, maintaining correct dependencies and network links.

---

## 4. What is the purpose of the Dockerfile? Walk through a basic example.

### Explanation:
A **Dockerfile** automates the creation of Docker images by defining step-by-step instructions.

### Example Dockerfile:
```dockerfile
FROM openjdk:17
WORKDIR /app
COPY target/myapp.jar .
CMD ["java", "-jar", "myapp.jar"]
````

### Explanation of Instructions:

* `FROM` – Base image
* `WORKDIR` – Sets working directory inside container
* `COPY` – Copies files into the container
* `CMD` – Command to run when container starts

### Real-World Example:

We used a Dockerfile to package our Spring Boot application. Jenkins built the image and pushed it to AWS ECR for deployment.

---

## 5. How does Docker networking work by default?

### Explanation:

By default, Docker uses the **bridge network** mode. Each container gets a private IP, and containers on the same bridge can communicate by name.

### Commands:

```bash
docker network ls
docker inspect bridge
```

### Real-World Example:

Our web and database containers were connected through a custom bridge network.
The backend accessed the database using the service name `db:3306`.

---

## 6. How do you create a custom Docker network and why?

### Explanation:

Custom networks provide better isolation, name resolution, and organized communication between related containers.

### Commands:

```bash
docker network create mynetwork
docker run -d --name db --network mynetwork mysql
docker run -d --name app --network mynetwork myapp:v1
```

### Real-World Example:

We created a network `shopnet` for our eCommerce containers so that only related services could communicate internally.

---

## 7. What’s the role of a Docker volume?

### Explanation:

Volumes are used to **persist container data** beyond the container’s lifecycle.
When a container is removed, volume data remains intact.

### Example Command:

```bash
docker run -v mydata:/var/lib/mysql mysql
```

### Real-World Example:

In our MySQL container, data was stored in a volume `db_data` to ensure that even if the container was recreated, customer data remained safe.

---

## 8. What are the types of Docker volumes and when do you use them?

### Types:

1. **Named Volumes** – Managed by Docker, stored under `/var/lib/docker/volumes/`
2. **Bind Mounts** – Link host directory to a container path
3. **Tmpfs Mounts** – Stored in memory, used for sensitive data

### Real-World Example:

* **Named volume:** For persistent MySQL data
* **Bind mount:** For sharing configuration files in development
* **Tmpfs:** For temporary cache or secrets

---

## 9. How can you persist data in Docker containers?

### Explanation:

Data persistence is achieved using **volumes** or **bind mounts**.

### Example Commands:

```bash
docker run -v appdata:/usr/src/app/data myapp
docker run -v /opt/logs:/app/logs log-service
```

### Real-World Example:

We used a bind mount `/opt/logs` to store application logs on the host system for analysis and troubleshooting.

---

## 10. What is the purpose of the EXPOSE instruction in a Dockerfile?

### Explanation:

`EXPOSE` indicates which port the container listens on at runtime.
It acts as **documentation** but doesn’t actually publish the port.

### Example Dockerfile:

```dockerfile
EXPOSE 8080
```

### Note:

To make it accessible externally:

```bash
docker run -p 8080:8080 myapp
```

### Real-World Example:

In our Java app Dockerfile, we exposed port 8080 for application access and used `-p` mapping during Jenkins deployment for testing.

---

